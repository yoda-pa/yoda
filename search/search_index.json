{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Yoda PA","text":"<p>Personal Assistant on the command line.</p> <p></p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install yodapa\n\nyoda --help\n</code></pre>"},{"location":"#configure-yoda","title":"Configure Yoda","text":"<pre><code>yoda configure\n</code></pre>"},{"location":"#plugins","title":"Plugins","text":""},{"location":"#write-your-own-plugin-for-yoda","title":"Write your own plugin for Yoda","text":"<p>Simply create a class with the <code>@yoda_plugin(name=\"plugin-name\")</code> decorator and add methods to it. The non-private methods will be automatically added as sub-commands to Yoda, with the command being the name you provide to the decorator.</p> <pre><code>import typer\nfrom yodapa.plugin_manager.decorator import yoda_plugin\n\n\n@yoda_plugin(name=\"hi\")\nclass HiPlugin:\n    \"\"\"\n    Hi plugin. Say hello.\n\n    Example:\n        $ yoda hi hello --name MP\n        $ yoda hi hello\n    \"\"\"\n\n    def hello(self, name: str = None):\n        \"\"\"Say hello.\"\"\"\n        name = name or \"Padawan\"\n        typer.echo(f\"Hello {name}!\")\n\n    def _private_method_should_not_be_added(self):\n        \"\"\"This method should not be added as a command.\"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"#development-setup","title":"Development setup","text":"<pre><code># 1. Install poetry from their website: https://python-poetry.org/docs/#installation\n\n# 2. Install dependencies and this package\npoetry install\n\n# 3. Activate the virtual environment\npoetry shell\n\n# Now you should be able to communicate with yoda\nyoda --help\n</code></pre>"},{"location":"#testing","title":"Testing","text":"<pre><code># Run tests when in the virtual environment\npytest\n</code></pre>"},{"location":"contributors/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"contributors/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"contributors/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"contributors/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"contributors/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"contributors/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at manparveshsinghrandhawa@gmail.com. The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"contributors/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at http://contributor-covenant.org/version/1/4</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2024 Man Parvesh Singh Randhawa</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"modules/","title":"Modules","text":"<p>Configuration manager class. Manages the configuration of Yoda.</p> Source code in <code>yodapa/config.py</code> <pre><code>class ConfigManager:\n    \"\"\"Configuration manager class. Manages the configuration of Yoda.\"\"\"\n\n    def __init__(self):\n        self.config_file = self.get_default_config_file()\n        self.config: Dict[str, Any] = dict()\n        self.load()\n\n    def load(self):\n        \"\"\"Load the configuration from the configuration file.\"\"\"\n        if self.config_file.exists():\n            with open(self.config_file) as f:\n                self.config = yaml.safe_load(f)\n        else:\n            self.config = self.get_default_config()\n\n    def save(self):\n        \"\"\"Save the configuration to the configuration file.\"\"\"\n        self.config_file.parent.mkdir(parents=True, exist_ok=True)\n        with open(self.config_file, \"w\") as f:\n            yaml.safe_dump(self.config, f)\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        \"\"\"Get a configuration value by key.\"\"\"\n        return self.config.get(key, default)\n\n    def set(self, key: str, value: Any):\n        \"\"\"Set a configuration value by key.\"\"\"\n        self.config[key] = value\n        self.save()\n\n    def get_yoda_config_dir(self) -&gt; Path:\n        return Path.home() / \".yoda\"\n\n    def get_yoda_plugins_dir(self) -&gt; Path:\n        return self.get_yoda_config_dir() / \"plugins\"\n\n    def get_default_config_file(self) -&gt; Path:\n        return self.get_yoda_config_dir() / \"config.yaml\"\n\n    def get_default_config(self) -&gt; Dict[str, Any]:\n        return {\n            \"user\": \"Skywalker\",\n            \"plugins\": {},\n        }\n</code></pre>"},{"location":"modules/#yodapa.config.ConfigManager.get","title":"<code>get(key, default=None)</code>","text":"<p>Get a configuration value by key.</p> Source code in <code>yodapa/config.py</code> <pre><code>def get(self, key: str, default: Any = None) -&gt; Any:\n    \"\"\"Get a configuration value by key.\"\"\"\n    return self.config.get(key, default)\n</code></pre>"},{"location":"modules/#yodapa.config.ConfigManager.load","title":"<code>load()</code>","text":"<p>Load the configuration from the configuration file.</p> Source code in <code>yodapa/config.py</code> <pre><code>def load(self):\n    \"\"\"Load the configuration from the configuration file.\"\"\"\n    if self.config_file.exists():\n        with open(self.config_file) as f:\n            self.config = yaml.safe_load(f)\n    else:\n        self.config = self.get_default_config()\n</code></pre>"},{"location":"modules/#yodapa.config.ConfigManager.save","title":"<code>save()</code>","text":"<p>Save the configuration to the configuration file.</p> Source code in <code>yodapa/config.py</code> <pre><code>def save(self):\n    \"\"\"Save the configuration to the configuration file.\"\"\"\n    self.config_file.parent.mkdir(parents=True, exist_ok=True)\n    with open(self.config_file, \"w\") as f:\n        yaml.safe_dump(self.config, f)\n</code></pre>"},{"location":"modules/#yodapa.config.ConfigManager.set","title":"<code>set(key, value)</code>","text":"<p>Set a configuration value by key.</p> Source code in <code>yodapa/config.py</code> <pre><code>def set(self, key: str, value: Any):\n    \"\"\"Set a configuration value by key.\"\"\"\n    self.config[key] = value\n    self.save()\n</code></pre>"},{"location":"plugins/","title":"Plugin Management","text":""},{"location":"plugins/#decorator","title":"Decorator","text":""},{"location":"plugins/#yodapa.plugin_manager.decorator.yoda_plugin","title":"<code>yoda_plugin(name=None)</code>","text":"<p>Decorator to turn a class into a Yoda PA plugin. All public methods of the class are added as Typer commands.</p> Source code in <code>yodapa/plugin_manager/decorator.py</code> <pre><code>def yoda_plugin(name: Annotated[Optional[str], typer.Argument()] = None):\n    \"\"\"\n    Decorator to turn a class into a Yoda PA plugin.\n    All public methods of the class are added as Typer commands.\n    \"\"\"\n\n    def decorator(cls):\n        nonlocal name\n        name = name or cls.__name__.lower()\n\n        def __init__(self):\n            self.typer_app = typer.Typer(name=name, help=f\"{name} plugin commands\")\n\n            for method_name, method in inspect.getmembers(self, predicate=inspect.ismethod):\n                # Skip private methods\n                if method_name.startswith(\"_\"):\n                    continue\n\n                self.typer_app.command()(method)\n\n        cls.__init__ = __init__\n        cls.name = name\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"plugins/#plugin-manager","title":"Plugin Manager","text":"<p>Plugin manager class. Manages the plugins in the 'plugins' directory and the local plugins directory.</p> Source code in <code>yodapa/plugin_manager/plugin.py</code> <pre><code>class PluginManager:\n    \"\"\"Plugin manager class. Manages the plugins in the 'plugins' directory and the local plugins directory.\"\"\"\n\n    def __init__(self, app: typer.Typer, config: ConfigManager):\n        self.app: typer.Typer = app\n        self.config: ConfigManager = config\n        self.plugins: List = []\n\n    def discover_plugins(self):\n        \"\"\"Discover plugins in the 'plugins' directory and the local plugins directory.\"\"\"\n\n        # 1. Discover plugins within the 'plugins' directory\n        plugins_pkg = importlib.import_module('yodapa.plugins')\n        plugins_path = plugins_pkg.__path__\n\n        for finder, name, ispkg in pkgutil.iter_modules(plugins_path):\n            # print(\"finder\", finder, \"name\", name, \"ispkg\", ispkg)\n            try:\n                module = importlib.import_module(f'yodapa.plugins.{name}')\n                for attribute_name in dir(module):\n                    plugin_class = getattr(module, attribute_name)\n                    if inspect.isclass(plugin_class) and hasattr(plugin_class(), \"typer_app\"):\n                        plugin_instance = plugin_class()\n                        self.plugins.append(plugin_instance)\n            except Exception as e:\n                typer.echo(f\"Failed to load plugin {name}: {e}\", err=True)\n\n        # 2. Discover plugins in the local plugins directory\n        local_plugins_dir = self.config.get_yoda_plugins_dir()\n        if local_plugins_dir.exists() and local_plugins_dir.is_dir():\n            for finder, name, ispkg in pkgutil.iter_modules([str(local_plugins_dir)]):\n                # print(\"finder\", finder, \"name\", name, \"ispkg\", ispkg)\n                try:\n                    module_path = local_plugins_dir / f\"{name}.py\"\n                    if not module_path.exists():\n                        typer.echo(f\"Plugin module {name} does not exist at {module_path}\", err=True)\n                        continue\n\n                    # Load the module from the file path\n                    spec = importlib.util.spec_from_file_location(name, str(module_path))\n                    if spec is None:\n                        typer.echo(f\"Could not load spec for module {name}\", err=True)\n                        continue\n\n                    module = importlib.util.module_from_spec(spec)\n                    spec.loader.exec_module(module)\n\n                    # typer.echo(f\"Imported module: {module.__name__}\")\n\n                    # Find the plugin class in the module (same as above)\n                    for attribute_name in dir(module):\n                        plugin_class = getattr(module, attribute_name)\n                        if inspect.isclass(plugin_class) and hasattr(plugin_class(), \"typer_app\"):\n                            plugin_instance = plugin_class()\n                            self.plugins.append(plugin_instance)\n                except Exception as e:\n                    typer.echo(f\"Failed to load local plugin {name}: {e}\", err=True)\n\n        # uncomment to debug\n        # print(\"Plugins discovered:\", self.plugins)\n\n    def load_plugins(self):\n        \"\"\"Load the plugins into the yoda typer app.\"\"\"\n        for plugin in self.plugins:\n            try:\n                self.app.add_typer(plugin.typer_app, name=plugin.name, help=f\"{plugin.name} plugin commands\")\n                # typer.echo(f\"Loaded plugin: {plugin.name}\")\n            except Exception as e:\n                typer.echo(f\"Error loading plugin {plugin.name}: {e}\", err=True)\n\n    def enable_plugin(self, plugin_name: str):\n        # TODO: implement\n        pass\n\n    def disable_plugin(self, plugin_name: str):\n        # TODO: implement\n        pass\n</code></pre>"},{"location":"plugins/#yodapa.plugin_manager.plugin.PluginManager.discover_plugins","title":"<code>discover_plugins()</code>","text":"<p>Discover plugins in the 'plugins' directory and the local plugins directory.</p> Source code in <code>yodapa/plugin_manager/plugin.py</code> <pre><code>def discover_plugins(self):\n    \"\"\"Discover plugins in the 'plugins' directory and the local plugins directory.\"\"\"\n\n    # 1. Discover plugins within the 'plugins' directory\n    plugins_pkg = importlib.import_module('yodapa.plugins')\n    plugins_path = plugins_pkg.__path__\n\n    for finder, name, ispkg in pkgutil.iter_modules(plugins_path):\n        # print(\"finder\", finder, \"name\", name, \"ispkg\", ispkg)\n        try:\n            module = importlib.import_module(f'yodapa.plugins.{name}')\n            for attribute_name in dir(module):\n                plugin_class = getattr(module, attribute_name)\n                if inspect.isclass(plugin_class) and hasattr(plugin_class(), \"typer_app\"):\n                    plugin_instance = plugin_class()\n                    self.plugins.append(plugin_instance)\n        except Exception as e:\n            typer.echo(f\"Failed to load plugin {name}: {e}\", err=True)\n\n    # 2. Discover plugins in the local plugins directory\n    local_plugins_dir = self.config.get_yoda_plugins_dir()\n    if local_plugins_dir.exists() and local_plugins_dir.is_dir():\n        for finder, name, ispkg in pkgutil.iter_modules([str(local_plugins_dir)]):\n            # print(\"finder\", finder, \"name\", name, \"ispkg\", ispkg)\n            try:\n                module_path = local_plugins_dir / f\"{name}.py\"\n                if not module_path.exists():\n                    typer.echo(f\"Plugin module {name} does not exist at {module_path}\", err=True)\n                    continue\n\n                # Load the module from the file path\n                spec = importlib.util.spec_from_file_location(name, str(module_path))\n                if spec is None:\n                    typer.echo(f\"Could not load spec for module {name}\", err=True)\n                    continue\n\n                module = importlib.util.module_from_spec(spec)\n                spec.loader.exec_module(module)\n\n                # typer.echo(f\"Imported module: {module.__name__}\")\n\n                # Find the plugin class in the module (same as above)\n                for attribute_name in dir(module):\n                    plugin_class = getattr(module, attribute_name)\n                    if inspect.isclass(plugin_class) and hasattr(plugin_class(), \"typer_app\"):\n                        plugin_instance = plugin_class()\n                        self.plugins.append(plugin_instance)\n            except Exception as e:\n                typer.echo(f\"Failed to load local plugin {name}: {e}\", err=True)\n</code></pre>"},{"location":"plugins/#yodapa.plugin_manager.plugin.PluginManager.load_plugins","title":"<code>load_plugins()</code>","text":"<p>Load the plugins into the yoda typer app.</p> Source code in <code>yodapa/plugin_manager/plugin.py</code> <pre><code>def load_plugins(self):\n    \"\"\"Load the plugins into the yoda typer app.\"\"\"\n    for plugin in self.plugins:\n        try:\n            self.app.add_typer(plugin.typer_app, name=plugin.name, help=f\"{plugin.name} plugin commands\")\n            # typer.echo(f\"Loaded plugin: {plugin.name}\")\n        except Exception as e:\n            typer.echo(f\"Error loading plugin {plugin.name}: {e}\", err=True)\n</code></pre>"}]}